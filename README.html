<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="M. Moreno-Betancur, F. Leacy, D. Tompsett, I. White" />


<title>mice: The NARFCS procedure for sensitivity analyses</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore"><code>mice</code>: The NARFCS procedure for sensitivity analyses</h1>
<h4 class="author"><em>M. Moreno-Betancur, F. Leacy, D. Tompsett, I. White</em></h4>



<p>This document illustrates how to perform sensitivity analyses using the Not At Random Fully Conditional Specification (NARFCS) procedure implemented in an extension of the R package <code>mice</code>.</p>
<div id="background" class="section level2">
<h2>Background</h2>
<p>Standard multiple imputation procedures to deal with missing data typically rely on the marginal and conditional distributions of variables in the observed data to impute the missing values. This is for instance the basis of the Fully Conditional Specification (FCS) approach to handle multiple incomplete variables, which is generally implemented using Multiple Imputation by Chained Equations (MICE) as in the R package <code>mice</code> (<a href="https://www.jstatsoft.org/article/view/v045i03/v45i03.pdf">van Buuren S, Groothuis-Oudshoorn K., 2011</a>).</p>
<p>A <em>sensitivity analysis</em> in this setting aims at assessing how our results would change if the distribution of the missing data differed in a systematic way from that of the observed data, which is something that we cannot of course assess using the latter.</p>
<p>The NARFCS procedure was first formally studied by Leacy (2016), and generalises the so-called <em>delta-adjustment</em> sensitivity analysis method to the case with multiple incomplete variables within the FCS framework. In practical terms, the NARFCS procedure consists in shifting the imputations drawn at each iteration of MICE by a user-specified quantity that can vary across subjects, to reflect systematic departures of the missing data from the observed data distribution.</p>
<p>Tompsett et al. (in preparation) provide recommendations for the application of NARFCS in practice, particularly regarding the interpretation and elicitation of the sensitivity parameters required by the procedure. Here we present the syntax for applying NARFCS to a dataset using an extension of the package <code>mice</code> that includes dedicated imputation methods. At the moment, methods are available for continuous and binary variables only, called <code>normSens</code> and <code>logregSens</code> respectively. Their use requires additional arguments to be passed on to <code>mice</code>, as described below.</p>
</div>
<div id="installation-of-the-extension" class="section level2">
<h2>Installation of the extension</h2>
<p>The currently recommended version of the NARFCS extension of the package <code>mice</code> can be installed directly from GitHub using the <code>devtools</code> package, which must be first installed from CRAN by the user to proceed. Then it suffices to execute the following commands to install the NARFCS extension of <code>mice</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(devtools)
<span class="kw">install_github</span>(<span class="st">&quot;moreno-betancur/mice&quot;</span>)</code></pre></div>
</div>
<div id="loading-and-looking-at-example-dataset" class="section level2">
<h2>Loading and looking at example dataset</h2>
<p>(<a href="https://raw.githack.com/moreno-betancur/NARFCS/master/README.html">click here if you see raw rather than compiled Latex formulas below</a>)</p>
<p>To illustrate, we use a simulated dataset <code>datmis</code> (available for download <a href="https://rawgit.com/moreno-betancur/NARFCS/master/datmis.csv">here</a>) which consists of:</p>
<ul>
<li>a binary variable <span class="math inline">\(X\)</span>, taking the values “No” (the reference level) and “Yes”,</li>
<li>a continuous variable <span class="math inline">\(Y\)</span>, and</li>
<li>a categorical variable <span class="math inline">\(Z\)</span>, with 3 categories: “Cat0” (the reference level), “Cat1” and “Cat2”.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">datmis&lt;-<span class="kw">read.csv</span>(<span class="st">&quot;datmis.csv&quot;</span>)
<span class="kw">head</span>(datmis)</code></pre></div>
<pre><code>##      X          Y    Z
## 1   No   3.693582 Cat1
## 2   No -12.398012 Cat2
## 3   No -17.878958 Cat2
## 4   No -19.245551 Cat2
## 5 &lt;NA&gt;         NA Cat0
## 6   No   9.126956 Cat1</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(datmis)</code></pre></div>
<pre><code>##     X             Y              Z      
##  No  :264   Min.   :-32.700   Cat0:167  
##  Yes :141   1st Qu.: -5.713   Cat1:166  
##  NA's: 95   Median :  3.491   Cat2:167  
##             Mean   :  3.524             
##             3rd Qu.: 12.249             
##             Max.   : 49.663             
##             NA's   :108</code></pre>
<p>The variables <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> are incomplete and <span class="math inline">\(Z\)</span> is complete, and it is easily verified that a <em>complete case</em> analysis would discard around 30% of the records:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="dv">100</span> <span class="op">*</span><span class="st"> </span><span class="kw">c</span>(<span class="kw">sum</span>(<span class="kw">is.na</span>(datmis<span class="op">$</span>X)), <span class="kw">sum</span>(<span class="kw">is.na</span>(datmis<span class="op">$</span>Y)), <span class="kw">sum</span>(<span class="kw">is.na</span>(datmis<span class="op">$</span>Z)))<span class="op">/</span><span class="kw">nrow</span>(datmis)</code></pre></div>
<pre><code>## [1] 19.0 21.6  0.0</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="dv">100</span> <span class="op">*</span><span class="st"> </span><span class="kw">sum</span>(<span class="op">!</span><span class="kw">is.na</span>(datmis<span class="op">$</span>X) <span class="op">&amp;</span><span class="st"> </span><span class="op">!</span><span class="kw">is.na</span>(datmis<span class="op">$</span>Y) <span class="op">&amp;</span><span class="st"> </span><span class="op">!</span><span class="kw">is.na</span>(datmis<span class="op">$</span>Z))<span class="op">/</span><span class="kw">nrow</span>(datmis)</code></pre></div>
<pre><code>## [1] 70.6</code></pre>
<p>Suppose that the aim is to estimate the coefficient of <span class="math inline">\(X\)</span> in a linear regression of <span class="math inline">\(Y\)</span> on <span class="math inline">\(X\)</span> and <span class="math inline">\(Z\)</span>. Before illustrating NARFCS, we provide a recap of a standard FCS analysis one may do in this case. This will be the point of departure for the NARFCS sensitivity analysis and will also help to draw some parallels between the arguments provided to <code>mice</code> in the FCS analysis and those additional ones required for NARFCS.</p>
</div>
<div id="fcs-analysis" class="section level2">
<h2>FCS analysis</h2>
<div id="fcs-univariate-imputation-models" class="section level3">
<h3>FCS univariate imputation models</h3>
<p>A typical FCS analysis with <code>mice</code> would be to use a logistic model to impute <span class="math inline">\(X\)</span> and a linear model to impute <span class="math inline">\(Y\)</span>, both including <span class="math inline">\(Z\)</span> as predictor, and with <span class="math inline">\(Y\)</span> included as predictor in the imputation model for <span class="math inline">\(X\)</span> and vice-versa. A usual, for mathematical purposes, <span class="math inline">\(X\)</span> is taken to be the binary 0/1 indicator for the “Yes” category, and including <span class="math inline">\(Z\)</span> as predictor means that we include the binary indicators <span class="math inline">\(Z_1\)</span> and <span class="math inline">\(Z_2\)</span> for categories “Cat1” and “Cat2” in the models. Thus, the univariate imputation model for <span class="math inline">\(X\)</span> would specify the conditional expectation of <span class="math inline">\(X\)</span> given the other variables as follows: <span class="math display">\[\text{logit}\{E(X|Y,Z)\}=\beta_{X0}+ \beta_{XY} Y+ \beta_{XZ_{1}} Z_1+\beta_{XZ_{2}} Z_2.\]</span> Similarly, the model for <span class="math inline">\(Y\)</span> would specify: <span class="math display">\[ E(Y|X,Z)=\beta_{Y0}+ \beta_{YX} X + \beta_{YZ_{1}} Z_1+\beta_{YZ_{2}} Z_2.\]</span> and Var<span class="math inline">\((Y|X,Z)=\sigma^2\)</span>, assuming constant variance.</p>
</div>
<div id="running-fcs-with-mice" class="section level3">
<h3>Running FCS with mice</h3>
<p>This FCS analysis can be performed with <code>mice</code> by specifying the linear predictor of each of these models in either of two ways: using the matrix syntax (through the <code>predictorMatrix</code> argument) or using the formula syntax (through the <code>form</code> argument).</p>
<div id="matrix-syntax-for-fcs" class="section level4">
<h4>Matrix syntax for FCS</h4>
<p>With the matrix syntax, the analysis requires specifying the predictors of each imputation model through a matrix of dimension equal to the number of variables in the dataset (in this case 3). A cell with a 1 indicates that the column variable is included as predictor in the imputation model of the row variable, with both rows and columns representing the variables in the order in which they appear in the dataset. Other cells are set to zero:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(mice)</code></pre></div>
<pre><code>## Loading required package: lattice</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#Set-up predictor matrix</span>
predMatrix&lt;-<span class="kw">matrix</span>(<span class="kw">rep</span>(<span class="dv">0</span>,<span class="dv">9</span>),<span class="dt">ncol=</span><span class="dv">3</span>)
<span class="kw">colnames</span>(predMatrix)&lt;-<span class="kw">rownames</span>(predMatrix)&lt;-<span class="kw">names</span>(datmis)
predMatrix[<span class="st">&quot;X&quot;</span>,]&lt;-<span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>)
predMatrix[<span class="st">&quot;Y&quot;</span>,]&lt;-<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>)

predMatrix</code></pre></div>
<pre><code>##   X Y Z
## X 0 1 1
## Y 1 0 1
## Z 0 0 0</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#FCS analysis with matrix syntax</span>
impFCS&lt;-<span class="kw">mice</span>(datmis,<span class="dt">m=</span><span class="dv">5</span>, <span class="dt">method=</span><span class="kw">c</span>(<span class="st">&quot;logreg&quot;</span>,<span class="st">&quot;norm&quot;</span>,<span class="st">&quot;&quot;</span>), <span class="dt">predictorMatrix=</span>predMatrix,<span class="dt">seed=</span><span class="dv">234235</span>,<span class="dt">print=</span>F)

<span class="co">#Pool results from linear regression from imputed datasets:</span>
<span class="kw">pool</span>(<span class="kw">with</span>(impFCS,<span class="kw">lm</span>(Y<span class="op">~</span>X<span class="op">+</span>Z)))<span class="op">$</span>qbar</code></pre></div>
<pre><code>## (Intercept)          X2          Z2          Z3 
##   15.958084    6.594639  -13.450028  -26.004113</code></pre>
<p><strong>Note 1</strong>: For categorical variables, the function <code>pool</code> names the coefficients in the output according to the rank of the category. Thus “X2” corresponds to the second category of <span class="math inline">\(X\)</span>, and “Z2” and “Z3” to the second and third category of <span class="math inline">\(Z\)</span>, respectively. It is thus important to note that, if not instructed otherwise, R automatically orders the levels of a factor with the reference level first and the rest following in alphabetical order. We can check the order of the levels of a factor variable using the <code>levels</code> function:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">levels</span>(datmis<span class="op">$</span>X)</code></pre></div>
<pre><code>## [1] &quot;No&quot;  &quot;Yes&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">levels</span>(datmis<span class="op">$</span>Z)</code></pre></div>
<pre><code>## [1] &quot;Cat0&quot; &quot;Cat1&quot; &quot;Cat2&quot;</code></pre>
<p>To set the desired reference level, the user can use the <code>relevel</code> function (see <code>?relevel</code>).</p>
</div>
<div id="formula-syntax-for-fcs" class="section level4">
<h4>Formula syntax for FCS</h4>
<p>The formula syntax is sometimes more straightforward to use, especially when it comes to interactions (though for now we have none - see <strong>Note 2</strong> below). Each imputation model is specified using a formula in the same manner used for specifying models in R’s standard model-fitting functions:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#FCS analysis using formula syntax</span>
impFCS&lt;-<span class="kw">mice</span>(datmis,<span class="dt">m=</span><span class="dv">5</span>, <span class="dt">method=</span><span class="kw">c</span>(<span class="st">&quot;logreg&quot;</span>,<span class="st">&quot;norm&quot;</span>,<span class="st">&quot;&quot;</span>), <span class="dt">form=</span><span class="kw">c</span>(<span class="st">&quot;~1+Y+Z&quot;</span>,<span class="st">&quot;~1+X+Z&quot;</span>,<span class="st">&quot;&quot;</span>),<span class="dt">seed=</span><span class="dv">234235</span>,<span class="dt">print=</span>F)

<span class="co">#Pool results from linear regression from imputed datasets:</span>
<span class="kw">pool</span>(<span class="kw">with</span>(impFCS,<span class="kw">lm</span>(Y<span class="op">~</span>X<span class="op">+</span>Z)))<span class="op">$</span>qbar</code></pre></div>
<pre><code>## (Intercept)          X2          Z2          Z3 
##    15.98365     6.58963   -13.48023   -26.04045</code></pre>
<p>At a given MICE iteration, the <span class="math inline">\(\beta\)</span>-parameters in the imputation models above are estimated from the observed and current imputed values of all variables, but ultimately depend on the expectations and associations of the variables in the observed data. One can thus ask what would happen if some aspects of the distribution of the missing data differed from what can be inferred from the observed data. Answering this question is the aim of a sensitivity analysis, which we will perform using the NARFCS procedure.</p>
</div>
</div>
</div>
<div id="narfcs-analysis-to-assess-sensitivity" class="section level2">
<h2>NARFCS analysis to assess sensitivity</h2>
<div id="narfcs-univariate-imputation-models" class="section level3">
<h3>NARFCS univariate imputation models</h3>
<p>NARFCS (Leacy 2016) is a generalisation to the case with multiple incomplete variables of the so-called <em>delta-adjustment</em> method for sensitivity analyses. In the case of one incomplete variable, we have previously used the method both for continuous (<a href="http://journals.sagepub.com/doi/abs/10.1177/0962280213490014">Moreno-Betancur and Chavance, 2016</a>) and binary (<a href="https://academic.oup.com/aje/article-lookup/doi/10.1093/aje/kww107">Leacy et al. 2017</a>; <a href="http://onlinelibrary.wiley.com/doi/10.1111/biom.12295/full">Moreno-Betancur et al. 2015</a>) variables, and various other examples exist in the literature.</p>
<p>A sensitivity analysis using the NARFCS procedure aims at shifting the imputations drawn at each iteration by a constant or, more generally, by a quantity determined by a linear combination of the variables already included in the imputation model. When imputing a binary variable, it is the linear predictor of the imputation model that is shifted prior to drawing the imputed value.</p>
<p>Since only the imputed values are shifted, and not the observed, this shift only concerns individuals with the corresponding value missing. That is, if <span class="math inline">\(M_X\)</span> and <span class="math inline">\(M_Y\)</span> denote the missingness indicators of <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> (i.e. <span class="math inline">\(M_X=1\)</span> if <span class="math inline">\(X\)</span> is missing and <span class="math inline">\(M_X=0\)</span> otherwise, and similarly for <span class="math inline">\(M_Y\)</span>) then the shift concerns only individuals with <span class="math inline">\(M_X=1\)</span> if <span class="math inline">\(X\)</span> is being imputed, and <span class="math inline">\(M_Y=1\)</span> if <span class="math inline">\(Y\)</span> is being imputed. Formally, this amounts to specifying, for each incomplete variable, a univariate imputation model with an additional term representing an interaction between the missingness indicator and the chosen linear combination for the shift. In our example, this could be as follows:</p>
<span class="math display">\[\begin{align}
\text{logit}\{E(X|Y,Z,M_X)\} =&amp;\underbrace{\beta_{X0}+ \beta_{XY} Y+ \beta_{XZ_{1}} Z_1+\beta_{XZ_{2}} Z_2}_{\text{IDENTIFIABLE PART}}\\ &amp;+\underbrace{M_X*(\delta_{X0}+\delta_{XY}Y+\delta_{XZ_1}Z_1+\delta_{XZ_2}Z_2)}_\text{UNIDENTIFIABLE PART}.
\end{align}\]</span>
<p>and</p>
<p><span class="math display">\[ E(Y|X,M_Y)=\underbrace{\beta_{Y0}+ \beta_{YX} X + \beta_{YZ_{1}} Z_1+\beta_{YZ_{2}} Z_2}_{\text{IDENTIFIABLE PART}} +\underbrace{M_Y*(\delta_{Y0}+\delta_{YX}X+\delta_{YZ_1}Z_1+\delta_{YZ_2}Z_2)}_\text{UNIDENTIFIABLE PART}.\]</span></p>
<p>The <span class="math inline">\(\delta\)</span>-parameters that make up the linear combination in the shifts are called <em>sensitivity parameters</em>. These values describe the way in which the distribution of the missing data departs from that of the observed data, and as such are not estimable from the observed data, that is, they are unidentifiable. Thus, the NARFCS model consists of an identifiable part, with <span class="math inline">\(\beta\)</span>-parameters estimated from observed data, and an unidentifiable part, with <span class="math inline">\(\delta\)</span>- (sensitivity) parameters.</p>
<p>Typically, plausible ranges for the latter would be elicited from experts. Tompsett et al. (in preparation) provide a detailed study of the issue of sensitivity parameter elicitation in NARFCS, including methodology and guidelines. It is important to note here that sensitivity parameters must be specified on the log-odds scale when imputing a binary variable.</p>
<p>Of course, given that each sensitivity parameter will be varied across a range of values, for the sake of parsimony we will often assume that many of the <span class="math inline">\(\delta\)</span>-parameters are zero (i.e. exclude the term from the unidentifiable part), and we will vary only a key subset of them across a range of non-zero values according to the context and target parameter of interest. Indeed, each set of values for the set of sensitivity parameters will yield one set of results for the analysis. Thus, a key aspect of sensitivity analyses is how to process and report the large volume of results that arises from these analyses. This is beyond the scope of this document and we refer the reader to the aforementioned references for some examples.</p>
<p>Here, we show how to perform the NARFCS analysis with <code>mice</code> for one given set of values for the <span class="math inline">\(\delta\)</span>-parameters in our example. Specifically, in the model for <span class="math inline">\(X\)</span>, we set <span class="math inline">\(\delta_{X0}=-4\)</span> and <span class="math inline">\(\delta_{XY}=\delta_{XZ_1}=\delta_{XZ_2}=0\)</span>; that is, all terms except the intercept are excluded, so the shift when imputing <span class="math inline">\(X\)</span> is just a constant. For <span class="math inline">\(Y\)</span>, we set <span class="math inline">\(\delta_{Y0}=2\)</span>, <span class="math inline">\(\delta_{YX}=0\)</span> (i.e. the <span class="math inline">\(X\)</span>-term is excluded), <span class="math inline">\(\delta_{YZ_1}=1\)</span> and <span class="math inline">\(\delta_{YZ_2}=-3\)</span>.</p>
</div>
<div id="running-narfcs-with-mice" class="section level3">
<h3>Running NARFCS with mice</h3>
<p>The specification of the predictors in the identifiable part of the model is still done the same way as in the FCS analysis, using the <code>predictorMatrix</code> or <code>form</code> arguments. To specify the unidentifiable part, the user must make three changes to the way <code>mice</code> was called for the FCS analysis:</p>
<ol style="list-style-type: decimal">
<li><p>The user must specify special imputation methods for the incomplete variables that are to be imputed using NARFCS, which are not necessarily (nor usually) all. In our example we will apply NARFCS to <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span>. Instead of <code>&quot;norm&quot;</code> and <code>&quot;logreg&quot;</code>, the user must use <code>&quot;normSens&quot;</code> and <code>&quot;logregSens&quot;</code> according to the type (continuous or binary, respectively) of the incomplete variable. No other imputation methods have been extended for NARFCS at the moment.</p></li>
<li><p>The predictors in the unidentifiable part of the NARFCS model are specified through either of two additional arguments, <code>predictorSens</code> or <code>formSens</code>, in a similar way as for the identifiable part. By default only an intercept term is included.</p></li>
<li><p>The values of the sensitivity parameters have to be specified through the argument <code>parmSens</code>, which is a list object with one element per variable in the dataset in the order in which they appear there. Its elements are lists of vectors, specified as follows:</p></li>
</ol>
<ul>
<li><p>For variables in the dataset that are complete or to be imputed via standard FCS, the corresponding element is a list with an empty string (<code>&quot;&quot;</code>) as unique element, i.e. <code>list(&quot;&quot;)</code> (this is the default for all variables).</p></li>
<li><p>For variables to be imputed via NARFCS, it is a list of length equal to 1 (for the intercept) plus the number of variables included as predictors in the unidentifiable part of the imputation model, as specified through <code>predictorSens</code> or <code>formSens</code>. The first component is the sensitivity parameter corresponding to the intercept term, which is always included, and is thus a scalar (i.e. a vector of length 1). The following components are sensitivity parameter vectors, of length 1 except for factors (see below), corresponding to each of the predictor variables. If using the matrix syntax, these must be provided in the order in which they appear in the dataset (which is the order in which they appear in the matrix). If using the formula syntax, they are provided in the order in which they appear in the corresponding formula. For a factor predictor variable with <span class="math inline">\(K\)</span> categories, the element is a vector of length <span class="math inline">\(K-1\)</span> containing the sensitivity parameters for the <span class="math inline">\(K-1\)</span> indicator variables of the non-reference categories, following the order of the levels of that factor variable (see related <strong>Note 1</strong> above). These parameters are interpreted relative to the reference category, as usual. As a reminder, sensitivity parameters must be specified in the log-odds scale when imputing a binary variable (<code>&quot;logregSens&quot;</code> method).</p></li>
</ul>
<p>Since the specification of the <code>parmSens</code> argument is delicate, the program runs various checks to verify that the lengths of the lists and vectors are consistent with what was provided through <code>predictorSens</code> or <code>formSens</code> arguments, and provides informative error messages if this is not the case. When the procedure runs successfully and <code>printFlag=TRUE</code> (the default), the sensitivity parameters used for each predictor variable/factor level in each imputation model are printed out on the console so that the user can check that these correspond to what was intended. Carefully checking this output is highly recommended.</p>
<p>We will now illustrate how, together, these three steps allow us to apply NARFCS in our example using each possible syntax.</p>
<div id="matrix-syntax-for-narfcs" class="section level4">
<h4>Matrix syntax for NARFCS</h4>
<p>Using the matrix syntax, the NARFCS procedure with the above models and choice of parameters is performed as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#Set-up predictor matrix for identifiable part as before:</span>
predMatrix&lt;-<span class="kw">matrix</span>(<span class="kw">rep</span>(<span class="dv">0</span>,<span class="dv">9</span>),<span class="dt">ncol=</span><span class="dv">3</span>)
<span class="kw">colnames</span>(predMatrix)&lt;-<span class="kw">rownames</span>(predMatrix)&lt;-<span class="kw">names</span>(datmis)
predMatrix[<span class="st">&quot;X&quot;</span>,]&lt;-<span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>)
predMatrix[<span class="st">&quot;Y&quot;</span>,]&lt;-<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>)

predMatrix</code></pre></div>
<pre><code>##   X Y Z
## X 0 1 1
## Y 1 0 1
## Z 0 0 0</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#Set-up predictor matrix for unidentifiable part:</span>
predSens&lt;-<span class="kw">matrix</span>(<span class="kw">rep</span>(<span class="dv">0</span>,<span class="dv">9</span>),<span class="dt">ncol=</span><span class="dv">3</span>)
<span class="kw">colnames</span>(predSens)&lt;-<span class="kw">paste</span>(<span class="st">&quot;:&quot;</span>,<span class="kw">names</span>(datmis),<span class="dt">sep=</span><span class="st">&quot;&quot;</span>)
<span class="kw">rownames</span>(predSens)&lt;-<span class="kw">names</span>(datmis)

predSens[<span class="st">&quot;X&quot;</span>,]&lt;-<span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>)
predSens[<span class="st">&quot;Y&quot;</span>,]&lt;-<span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>)

predSens</code></pre></div>
<pre><code>##   :X :Y :Z
## X  0  0  0
## Y  0  0  1
## Z  0  0  0</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#Set-up list with sensitivity parameter values</span>

pSens&lt;-<span class="kw">rep</span>(<span class="kw">list</span>(<span class="kw">list</span>(<span class="st">&quot;&quot;</span>)), <span class="kw">ncol</span>(datmis))
<span class="kw">names</span>(pSens)&lt;-<span class="kw">names</span>(datmis)
pSens[[<span class="st">&quot;X&quot;</span>]]&lt;-<span class="kw">list</span>(<span class="op">-</span><span class="dv">4</span>)
pSens[[<span class="st">&quot;Y&quot;</span>]]&lt;-<span class="kw">list</span>(<span class="dv">2</span>,<span class="kw">c</span>(<span class="dv">1</span>,<span class="op">-</span><span class="dv">3</span>))

pSens</code></pre></div>
<pre><code>## $X
## $X[[1]]
## [1] -4
## 
## 
## $Y
## $Y[[1]]
## [1] 2
## 
## $Y[[2]]
## [1]  1 -3
## 
## 
## $Z
## $Z[[1]]
## [1] &quot;&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#NARFCS analysis using matrix syntax</span>
impNARFCS&lt;-<span class="kw">mice</span>(datmis,<span class="dt">m=</span><span class="dv">5</span>, <span class="dt">method=</span><span class="kw">c</span>(<span class="st">&quot;logregSens&quot;</span>,<span class="st">&quot;normSens&quot;</span>,<span class="st">&quot;&quot;</span>), <span class="dt">predictorMatrix=</span>predMatrix,
                 <span class="dt">predictorSens=</span>predSens, <span class="dt">parmSens=</span>pSens, <span class="dt">seed=</span><span class="dv">234235</span>,<span class="dt">print=</span>F)

<span class="co">#Pool results from linear regression from imputed datasets:</span>
<span class="kw">pool</span>(<span class="kw">with</span>(impNARFCS,<span class="kw">lm</span>(Y<span class="op">~</span>X<span class="op">+</span>Z)))<span class="op">$</span>qbar</code></pre></div>
<pre><code>## (Intercept)          X2          Z2          Z3 
##   19.040240    3.314205  -14.497868  -28.276516</code></pre>
<p>Note that no predictors have been specified for <span class="math inline">\(X\)</span> in this part of the imputation model. Hence, only an intercept shift will be included.</p>
<p>If we extract the <code>predictorSens</code> matrix from the object returned by <code>mice</code>, we see that the names of the columns are preceded by a colon (“:”), and this will be the case even if we do not pre-specify these names ourselves as in the code above.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">impNARFCS<span class="op">$</span>predictorSens</code></pre></div>
<pre><code>##   :X :Y :Z
## X  0  0  0
## Y  0  0  1
## Z  0  0  0</code></pre>
<p>These names highlight that, contrary to the terms in <code>predictorMatrix</code>, the terms in <code>predictorSens</code> formally come into the model only as an interaction with the missingness indicator (i.e. only for the missing data) as described previously.</p>
</div>
<div id="formula-syntax-for-narfcs" class="section level4">
<h4>Formula syntax for NARFCS</h4>
<p>With the formula syntax, the analysis is performed as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#NARFCS analysis using formula syntax</span>
impNARFCS&lt;-<span class="kw">mice</span>(datmis,<span class="dt">m=</span><span class="dv">5</span>, <span class="dt">method=</span><span class="kw">c</span>(<span class="st">&quot;logregSens&quot;</span>,<span class="st">&quot;normSens&quot;</span>,<span class="st">&quot;&quot;</span>),  <span class="dt">form=</span><span class="kw">c</span>(<span class="st">&quot;~1+Y+Z&quot;</span>,<span class="st">&quot;~1+X+Z&quot;</span>,<span class="st">&quot;&quot;</span>),
                  <span class="dt">formSens=</span><span class="kw">c</span>(<span class="st">&quot;~1&quot;</span>,<span class="st">&quot;~1+Z&quot;</span>,<span class="st">&quot;&quot;</span>), <span class="dt">parmSens=</span>pSens, <span class="dt">seed=</span><span class="dv">234235</span>,<span class="dt">print=</span>F)

<span class="co">#Pool results from linear regression from imputed datasets:</span>
<span class="kw">pool</span>(<span class="kw">with</span>(impNARFCS,<span class="kw">lm</span>(Y<span class="op">~</span>X<span class="op">+</span>Z)))<span class="op">$</span>qbar</code></pre></div>
<pre><code>## (Intercept)          X2          Z2          Z3 
##   19.357351    3.457046  -15.519064  -28.400211</code></pre>
<p>As with the matrix syntax, only an intercept shift will be included for <span class="math inline">\(X\)</span> in the unidentifiable part of the model since no other predictors have been specified. This is however made more explicit with the formula syntax by the specification of the non-empty formula <code>&quot;~1&quot;</code>.</p>
<p><strong>Note 2:</strong> When including interactions between predictors in the unidentifiable part of the model, similar issues arise as in the typical FCS analysis. Specifically, using the matrix syntax, the user must use passive imputation and carefully specify the visiting sequence as described by <a href="https://www.jstatsoft.org/article/view/v045i03/v45i03.pdf">van Buuren and Groothuis-Oudshoorn (2011)</a>. The passive imputation requires in particular adding the variable(s) representing the interaction term (e.g. the product in the case of two continuous variables) to the dataset prior to calling <code>mice</code>. With the formula syntax none of this is required as the interaction term can be specified directly in the formula. In this case the two approaches will yield slightly different results (even when using the same seed) because the random values used to initialise missing values of the interaction variable (used by the matrix syntax) will be different to the product of the random values used to initialise missing values of the interacting variables (used by the formula syntax).</p>
</div>
</div>
</div>
<div id="references" class="section level2">
<h2>References</h2>
<p>Leacy FP. <em>Multiple imputation under missing not at random assumptions via fully conditional specification</em> (PhD thesis). University of Cambridge, 2016.</p>
<p><a href="https://onlinelibrary.wiley.com/doi/full/10.1002/sim.7643">Tompsett DM, Leacy FP, Moreno-Betancur M, Heron J, White IR.</a> On the use of the not at random fully conditional specification procedure (NARFCS) in practice. <em>Statistics in Medicine</em> 2018; Epub ahead of print 2 April 2018.</p>
<p><a href="https://www.jstatsoft.org/article/view/v045i03/v45i03.pdf">van Buuren S, Groothuis-Oudshoorn K.</a> mice: Multivariate Imputation by Chained Equations in R. <em>Journal of Statistical Software</em> 2011; 45(3), 1-67.</p>
<p><a href="http://journals.sagepub.com/doi/abs/10.1177/0962280213490014">Moreno-Betancur M, Chavance M.</a> Sensitivity analysis of incomplete longitudinal data departing from the missing at random assumption: Methodology and application in a clinical trial with drop-outs. <em>Statistical Methods in Medical Research</em> 2016; 25(4) 1471-1489.</p>
<p><a href="https://academic.oup.com/aje/article-lookup/doi/10.1093/aje/kww107">Leacy FP, Floyd S, Yates TA, White IR.</a> Analyses of Sensitivity to the Missing-at-Random Assumption Using Multiple Imputation With Delta Adjustment: Application to a Tuberculosis/HIV Prevalence Survey With Incomplete HIV-Status Data. <em>American Journal of Epidemiology</em> 2017, 185(4):304-315.</p>
<p><a href="http://onlinelibrary.wiley.com/doi/10.1111/biom.12295/full">Moreno-Betancur M, Rey G, Latouche A.</a> Direct likelihood inference and sensitivity analysis for competing risks regression with missing causes of failure. <em>Biometrics</em> 2015; 71(2):498-507.</p>
<div id="cite-this-document-as" class="section level4">
<h4>Cite this document as:</h4>
<p>Moreno-Betancur M, Leacy FP, Tompsett D, White I. “mice: The NARFCS procedure for sensitivity analyses” (Available at: <a href="https://github.com/moreno-betancur/NARFCS" class="uri">https://github.com/moreno-betancur/NARFCS</a>)</p>
</div>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
